name: Deploy to AWS ECS

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # ìˆ˜ë™ ì‹¤í–‰ ê°€ëŠ¥

env:
  AWS_REGION: ap-northeast-2
  APP_NAME: honbabnono

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false
        
    - name: Initialize Terraform and setup variables
      run: |
        cd terraform
        
        # Create terraform.tfvars if it doesn't exist
        if [ ! -f terraform.tfvars ]; then
          echo "Creating terraform.tfvars from example..."
          cp terraform.tfvars.example terraform.tfvars
        fi
        
        # Show the current configuration
        echo "Current terraform.tfvars:"
        cat terraform.tfvars
        
        terraform init
        
    - name: Check if infrastructure exists
      id: check-infra
      run: |
        cd terraform
        # Check if state file exists and has resources
        if terraform show -json 2>/dev/null | jq -e '.values.root_module.resources | length > 0' &>/dev/null; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Infrastructure already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "No infrastructure found, will create new"
        fi
        
    - name: Cleanup conflicting resources (if needed)
      run: |
        echo "ğŸ§¹ Starting cleanup of existing resources..."
        
        # ECS ì„œë¹„ìŠ¤ ìŠ¤ì¼€ì¼ ë‹¤ìš´ ë° ì‚­ì œ
        if aws ecs describe-services --cluster ${{ env.APP_NAME }}-cluster --services ${{ env.APP_NAME }}-service --region ${{ env.AWS_REGION }} 2>/dev/null | grep -q "ACTIVE"; then
          echo "ğŸ§¹ Scaling down ECS service..."
          aws ecs update-service --cluster ${{ env.APP_NAME }}-cluster --service ${{ env.APP_NAME }}-service --desired-count 0 --region ${{ env.AWS_REGION }} || true
          sleep 30
          aws ecs delete-service --cluster ${{ env.APP_NAME }}-cluster --service ${{ env.APP_NAME }}-service --region ${{ env.AWS_REGION }} || true
        fi
        
        # ECS í´ëŸ¬ìŠ¤í„° ì‚­ì œ
        if aws ecs describe-clusters --clusters ${{ env.APP_NAME }}-cluster --region ${{ env.AWS_REGION }} 2>/dev/null | grep -q "ACTIVE"; then
          echo "ğŸ§¹ Deleting ECS cluster..."
          aws ecs delete-cluster --cluster ${{ env.APP_NAME }}-cluster --region ${{ env.AWS_REGION }} || true
        fi
        
        # ALB ì‚­ì œ (Target Group ë³´ë‹¤ ë¨¼ì €)
        if aws elbv2 describe-load-balancers --names ${{ env.APP_NAME }}-alb --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ğŸ§¹ Cleaning up existing ALB..."
          ALB_ARN=$(aws elbv2 describe-load-balancers --names ${{ env.APP_NAME }}-alb --region ${{ env.AWS_REGION }} --query 'LoadBalancers[0].LoadBalancerArn' --output text)
          aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN --region ${{ env.AWS_REGION }} || true
          echo "â³ Waiting for ALB deletion..."
          sleep 60
        fi
        
        # Target Group ì‚­ì œ
        if aws elbv2 describe-target-groups --names ${{ env.APP_NAME }}-tg --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ğŸ§¹ Cleaning up existing Target Group..."
          TG_ARN=$(aws elbv2 describe-target-groups --names ${{ env.APP_NAME }}-tg --region ${{ env.AWS_REGION }} --query 'TargetGroups[0].TargetGroupArn' --output text)
          aws elbv2 delete-target-group --target-group-arn $TG_ARN --region ${{ env.AWS_REGION }} || true
        fi
        
        # ë³´ì•ˆ ê·¸ë£¹ ì‚­ì œ
        echo "ğŸ§¹ Cleaning up security groups..."
        aws ec2 delete-security-group --group-name ${{ env.APP_NAME }}-alb-sg --region ${{ env.AWS_REGION }} 2>/dev/null || true
        aws ec2 delete-security-group --group-name ${{ env.APP_NAME }}-ecs-tasks-sg --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # IAM ì—­í• ë“¤ ì •ë¦¬
        echo "ğŸ§¹ Cleaning up existing IAM roles..."
        aws iam detach-role-policy --role-name ${{ env.APP_NAME }}-ecs-task-execution-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy 2>/dev/null || true
        aws iam delete-role --role-name ${{ env.APP_NAME }}-ecs-task-execution-role 2>/dev/null || true
        aws iam delete-role --role-name ${{ env.APP_NAME }}-ecs-task-role 2>/dev/null || true
        
        # ECR ë¦¬í¬ì§€í† ë¦¬ ì‚­ì œ
        if aws ecr describe-repositories --repository-names ${{ env.APP_NAME }}-app --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ğŸ§¹ Cleaning up existing ECR repository..."
          aws ecr delete-repository --repository-name ${{ env.APP_NAME }}-app --force --region ${{ env.AWS_REGION }} || true
        fi
        
        echo "âœ… Cleanup completed, waiting 60 seconds for AWS propagation..."
        sleep 60
        
    - name: Deploy infrastructure
      run: |
        cd terraform
        terraform plan
        terraform apply -auto-approve
        
    - name: Get ECR repository URL
      id: ecr-url
      run: |
        cd terraform
        # Wait a moment for outputs to be available
        sleep 10
        
        # Try to get ECR URL with error handling
        if ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null); then
          echo "ecr_url=$ECR_URL" >> $GITHUB_OUTPUT
          echo "âœ… ECR URL: $ECR_URL"
        else
          echo "âŒ Failed to get ECR URL, checking terraform state..."
          terraform show
          exit 1
        fi
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Build Docker image
      run: |
        docker build -t ${{ env.APP_NAME }} .
        
    - name: Tag and push Docker image
      run: |
        docker tag ${{ env.APP_NAME }}:latest ${{ steps.ecr-url.outputs.ecr_url }}:latest
        docker tag ${{ env.APP_NAME }}:latest ${{ steps.ecr-url.outputs.ecr_url }}:${{ github.sha }}
        docker push ${{ steps.ecr-url.outputs.ecr_url }}:latest
        docker push ${{ steps.ecr-url.outputs.ecr_url }}:${{ github.sha }}
        
    - name: Update ECS service
      run: |
        aws ecs update-service \
          --cluster ${{ env.APP_NAME }}-cluster \
          --service ${{ env.APP_NAME }}-service \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
          
    - name: Wait for deployment to complete
      run: |
        aws ecs wait services-stable \
          --cluster ${{ env.APP_NAME }}-cluster \
          --services ${{ env.APP_NAME }}-service \
          --region ${{ env.AWS_REGION }}
          
    - name: Get application URL
      id: app-url
      run: |
        cd terraform
        APP_URL=$(terraform output -raw application_url)
        DOMAIN_NAME=$(terraform output -raw domain_name)
        echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
        echo "domain_name=$DOMAIN_NAME" >> $GITHUB_OUTPUT
        
    - name: Get nameservers and domain info
      id: domain-info
      run: |
        cd terraform
        NAMESERVERS=$(terraform output -raw nameservers 2>/dev/null || echo "Not applicable")
        DOMAIN_INSTRUCTIONS=$(terraform output -raw domain_setup_instructions 2>/dev/null || echo "No domain configured")
        echo "nameservers=$NAMESERVERS" >> $GITHUB_OUTPUT
        echo "instructions=$DOMAIN_INSTRUCTIONS" >> $GITHUB_OUTPUT
        
    - name: Deployment success notification
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸŒ Application URL: ${{ steps.app-url.outputs.app_url }}"
        echo "ğŸ·ï¸  Domain: ${{ steps.app-url.outputs.domain_name }}"
        echo "ğŸ“¦ Docker image: ${{ steps.ecr-url.outputs.ecr_url }}:${{ github.sha }}"
        echo ""
        if [[ "${{ steps.app-url.outputs.domain_name }}" != "Not configured" ]]; then
          echo "ğŸ”’ SSL Certificate: Automatically configured"
          echo "ğŸŒ HTTPS redirect: Enabled"
          echo ""
          echo "ğŸ“‹ IMPORTANT: Configure these nameservers in your domain registrar:"
          echo "${{ steps.domain-info.outputs.nameservers }}"
          echo ""
          echo "ğŸ“– Instructions: ${{ steps.domain-info.outputs.instructions }}"
        fi